{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Index","text":""},{"location":"#overview","title":"Overview","text":"<p>ts-scan is the ultimate scanner resulting from several years of experience with scanning code for license information, vulnerabilities or malware across a plethora of sources, be it plain text files, packages, docker images or even binaries across as many environments as possible.</p> <p>Thus, we strive to provide a sort of a suiss army knife for scanning in the most comprehensive and comfortable way. And since we were not educated to do all day long this sort of work, we designed it to support automation.</p> <p>This help has been designed to support you in making the best use of it. To get a quick entry we outline different use cases and describe how to achieve the particular goal. A general article will give you an overview of the design and another article explains how to use ts-scan together with the TrustSource platform. However, ts-scan is standalone and can be used with every backend.</p> <p>To get a quick intro, jump to any of the following use cases:</p> <ul> <li>Architecture Overview &amp; supported Ecosystems</li> <li>Installation </li> <li> <p>Capabilities</p> <ul> <li>See Usage page on general guidance</li> <li>Scanning for dependencies (creating SBOMs)</li> <li>Scanning for licenses</li> <li>Scanning for encryption</li> <li>Scan for Known Vulnerabilities</li> <li>Scan for malware</li> <li>Scan for known software snippets</li> </ul> </li> <li> <p>Operations examples</p> </li> <li>Scanning different artefacts</li> <li>Auto-create SBOMs</li> <li>Prevent check-in of vulnerable dependencies</li> <li>Converting between different SBOM formats</li> </ul>"},{"location":"#getting-support","title":"Getting Support","text":"<p>ts-scan is open source and supported through this repository. As a TrustSource subscriber, you may contact TrustSource support for help. As a community user, please file a ticket with the repo.  </p> <p>You may also find additional information and learning materials on specific scanning issues/topics in our open TrustSource Knowledgebase.</p>"},{"location":"#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>TrustSource supports a coordinated vulnerability disclosure procedure for its platform. ts-scan follows that schema and vulnerabilities identified should follow this procedure. Please find all details in our Security Policy.</p>"},{"location":"CHANGELOG/","title":"ts-scan Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#110-2025-03-04","title":"[1.1.0] - 2025-03-04","text":""},{"location":"CHANGELOG/#new-features","title":"New Features","text":"<pre><code>* Added \"analyse\" and \"convert\" commands\n* Enhanced results enrichment using the SCANOSS API\n* Implemented vulnerability checks for scans using the TrustSource API\n* Added support for SPDX and CycloneDX as input/output formats\n* Published documentation as GitHub Pages\n</code></pre>"},{"location":"CHANGELOG/#100-2024-11-06","title":"[1.0.0] - 2024-11-06","text":""},{"location":"CHANGELOG/#new-features_1","title":"New Features","text":"<pre><code>* Forwarding parameters to PM tools\n* Specifying executable paths\n* Ignoring package managers while scanning\n* Improved import of results produced by the Syft scanner\n* Scan target can be now an URI that can be scanned by Syft enabling docker image scanning\n</code></pre>"},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<pre><code>* Fixed scanning of NPM and NuGet packages\n* Fixed scanning of Maven projects with submodules\n</code></pre>"},{"location":"CHANGELOG/#030-2024-01-22","title":"[0.3.0] - 2024-01-22","text":""},{"location":"CHANGELOG/#new-features_2","title":"New Features","text":"<pre><code>* Add support for the Syft scanner. The option '--use-syft' enables dependency scanning using Syft\n* Added options '--tag' and '--branch' to the scan command to attach the VCS's tag/branch to the module\n</code></pre>"},{"location":"CHANGELOG/#022-2023-10-04","title":"[0.2.2] - 2023-10-04","text":""},{"location":"CHANGELOG/#fixes_1","title":"Fixes","text":"<pre><code>* Fix Maven issues on Windows\n</code></pre>"},{"location":"CHANGELOG/#new-features_3","title":"New Features","text":"<pre><code>* Improved resolution of remote repositories for Maven\n</code></pre>"},{"location":"CHANGELOG/#021-2023-09-10","title":"[0.2.1] - 2023-09-10","text":""},{"location":"CHANGELOG/#fixes_2","title":"Fixes","text":"<pre><code>* Fix package's setup\n</code></pre>"},{"location":"CHANGELOG/#020-2023-09-08","title":"[0.2.0] - 2023-09-08","text":""},{"location":"CHANGELOG/#new-features_4","title":"New Features","text":"<pre><code>* Add support for Maven, NPM and Nuget package managers\n* Extraction of sources URLs for Maven packages\n</code></pre>"},{"location":"CHANGELOG/#012-2023-04-04","title":"[0.1.2] - 2023-04-04","text":""},{"location":"CHANGELOG/#new-features_5","title":"New Features","text":"<pre><code>* Improve/adjust interfaces for adding new pakcage managers\n</code></pre>"},{"location":"CHANGELOG/#fixes_3","title":"Fixes","text":"<pre><code>* Minor bug fixes\n</code></pre>"},{"location":"CHANGELOG/#011-2023-04-03","title":"[0.1.1] - 2023-04-03","text":""},{"location":"CHANGELOG/#new-features_6","title":"New Features","text":"<pre><code>* License identification in license files from Python's wheel packages\n</code></pre>"},{"location":"CHANGELOG/#010-2023-03-13","title":"[0.1.0] - 2023-03-13","text":""},{"location":"CHANGELOG/#new-features_7","title":"New Features","text":"<pre><code>* Scanning of PyPi packages\n* Uploading of TS scans\n* Importing of SPDX (JSON and RDF) and CycloneDX SBOMs\n</code></pre>"},{"location":"about/","title":"About ts-scan","text":"<p>ts-scan is the latest scanner we developed. In the early stages, we developed scanners per each development environment. But soon we got overwhelmed with all the update requirements since all ecosystems tend to evolve. In addition our customers kept asking us for integration of here and there and not all supporters kept with the command definitions leading to different command sets...</p> <p>To make a long story short, having one tool covering all different ecosystems with a plugin mechanism allowing to add more ecosystems seems much simpler to maintain. Here we are: ts-scan.</p>"},{"location":"about/#about-trustsource","title":"About TrustSource","text":"<p>TrustSource is a brand representing a SaaS-solution that supports companies to cope with all sort of regulations to comply with when developing and distributing software, such as ISO/IEC 5230 (OpenChain on Oopen source compliance),  ISO/IEC 18974 (Open Source Security Assurance) or the Cyber Resilience Act (CRA) introduced by the European Union in October 2024. </p> <p>While the platform is provided as a managed service, the scanners as well as the core itself are available as open source solutions. You may use it to self host the  </p>"},{"location":"about/#about-eacg","title":"About EACG","text":"<p>EACG is the company behind TrustSource. EACG is an enterprise architecture consulting company, that has started the endavour in 2014. EACG supports its clients with design and delivery of digital business models. Explorationa and relisation of the prototypes and development of the first business units are part of their eingagement. This very early lead to the question of licenses and ownership. </p> <p>Based on the experiences how fast a wrong license may enter the repository automated SBOM creation has been invented before even the SBOM became a dominating slogan. Vulnerbaility management has been added 2018 as a logical consequence, the service started to become interesting to others... </p>"},{"location":"about/#about-eacg-operations-services","title":"About EACG Operations Services","text":"<p>EACG decided to hand the operations of the platform to its AWS operations subsidiary. Thus EACG OS is taking care to run and manage the platform as well as the provisioning of support services while EACG is taking care for the individual consulting services. You may find further information on the EACG website. Find here links to further information:</p> <ul> <li>General terms and conditions, </li> <li>our privacy policy,</li> <li>the security policy,</li> <li>the shared security responsibility model, </li> <li>our knowledge base </li> <li>the service status information </li> </ul>"},{"location":"adding/","title":"Adding Features","text":"<p>We highly apperaciate any kind of support in enhancing the capabilities further. On our current roadmap you may see, how our priorities are aligned. </p> <p>[!IMPORTANT]</p> <p>PLEASE NOTE: To simplify integration of additional featurs, we have provided a short summary of how to add additional capabiliities in the following section as well as a few guidelines on how we want the code to be developed. See the guidelines for details. </p>"},{"location":"adding/#1-decide-where-to-add","title":"1. Decide where to add","text":"<p>Before you start adding, decide on where you want to add featurs. Are you planning to add an additional ecosystem, e.g. PHP or C#? then you should add this to ts-scan itself. Are you instead planning to add something that will work on the file-level, then you amy prefer to add to ts-deepscan, the integrated file handler.</p> <p>Please also have a look at the roadmap to get an idea on what is already planned, so that we do not waste resources in implementuing things twice.</p> <p>Given, you made these decisions, you may start.  </p>"},{"location":"adding/#2-be-aware-of-the-liecense","title":"2. Be aware of the liecense","text":"<p>We expect all contributions to follow the Apache-2.0 licensing schema. It is simple, safe and straight forward. It ensures freedom to use withoutt the demand to prescribe what you will do with it. </p> <p>[!IMPORTANT]</p> <p>PLEASE NOTE: We publish all our solutions under the Apache-2.0 license. Some licenses may not comply with licensing under Apache-2.0. We will check pull requests and might return to you in case we will find non-compliantly licensed components or snippets.</p> <p>By submitting a Pull Reuest we assume that you will confirm your agreement with the licensing your contribution under Apache-2.0 as well. </p>"},{"location":"adding/#3-submitting-issues","title":"3. Submitting Issues","text":"<p>We are happy to receive useful information supporting us in improving our tooling. So feel free to open issues in the corresponding section of this repository or the deepscan repository. We will try our best to close the bugs accordingly. </p> <p>When submitting a bug, please ensure that you provide us with </p> <ul> <li>Version of tools you were using</li> <li>Version of Python used in your environment</li> <li>Information on how to reproduce the bug, e.g.:   steps followed, expected bahviour, actual baheviour, further relevant information and/or logs</li> </ul> <p>Thank you!</p>"},{"location":"adding/#4-submitting-vulnerabilities","title":"4. Submitting Vulnerabilities","text":"<p>If you see or experience something that may impact the confidentiality, Integrity or availability of our TrustSource solution or the APIs of any our partners, please let us know. For such cases please refrain from opening a public issue!</p> <p>For such cases please see our Security Policy for information on how to confidentially submit vulnerabilities.</p>"},{"location":"adding/#5-submitting-code","title":"5. Submitting Code","text":"<p>We appreciate all sort of support. So, if you are willing to develop a feature that you think could be useful, feel free to discuss with us in advance. However, even if you prefer to just push the code, please follow the coding gudelines.</p> <p>To create a pull request, please</p> <ul> <li>clone the repo</li> <li>create a branch for your work, e.g. <code>fix-issue-123</code> or <code>feature/your-feature</code></li> <li>allow us to follow your work by providing friendly commit messages</li> <li>test thoroughly and do not forget to provide the tests in case you added functionality</li> <li>commit the reuest stating</li> <li>why it has been introduced </li> <li>what it tries to achieve and how</li> <li>the dependencies added</li> <li>prevent your editor from reformatting, so that we may understand the changes</li> <li>be patient, we try to review and retrun as soon as possible. </li> </ul> <p>Thank you in advance for your support!!!</p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>ts-scan is a commandline utility developed in python to simplify all code compliance related tasks and unify the handling across different environments. For DevOps this means, you may use the same command set across different environments, whether you are building Java, Go or Python.</p> <p></p> <p>With ts-scan you will be able to perform all sorts of scans. Whether you want to compose a Software Bill of Materials (SBOM), check a repository for hidden license information, check for malware or just scan a Docker file. All can be done using the same tool. </p>"},{"location":"architecture/#system-components","title":"System Components","text":"<p>To achieve this, we assembled a combination of best of breed solutions. This comprises</p> <ul> <li>Syft: supporting the decomposition of Docker images and derivation of SBOMs form an image. What we like about Syft is its ability to assess images as well as Docker files.</li> <li>Scancode: extends deepscan capabilities to assess non-text files in the search for hidden license information and copright texts. NexB, the authors of Scancode, maintain a huge library of keys, patterns and license information. </li> <li>SCANOSS: The fingerprinting mechanism by SCANOSS is unique as well as their data archive. Sitting on a huge database of internets history, it is possible to identify already seen code snippets and derive potential 3rd party copyrights. Especially in the era of AI-driven development code ownership becomes a topic of growing concern. </li> <li>PyMinr: Is our Python wrapper around the minr implementation, a search algorithm to identify encryption algorithms within the code. This is important for import and export controls but also to fortify your solutions against hte upcoming Quatum computing era.</li> <li>Yara: is the quasi standard for malware assessment. Whether you are looking into binaries or are searching for specific text combinations, yara expressions will be able to identify it, if it exists. However, you also may use yara to improve your findings. Learn more in this blogpost.</li> </ul> <p>Besides these cool tools we also provide a few capabilities to the party:</p> <ul> <li>ts-scan: Is not only the orchestrator but has the ability to identify the build environment, execute the corresponding package manager and pull all transitive packages, if required. These packages then will assessed using </li> <li>ts-deepscan: The repo/file scanner, we provided. ts-deepcan combines all the file based scanning capabilities described above. Its origin is license identification. DeepScan has the ability to discover known text fragments, allowing to identify licenses, even when they are slightly transformed or changed using similarity search.  </li> </ul> <p>ts-scan can write its results either into a local file using the TrustSource, SPDX or CycloneDX formats or transfer the results to the TrustSource platform for further treatment using the UPLOAD verb..</p>"},{"location":"architecture/#package-managers","title":"Package Managers","text":"<p>For the sake of simplicity we do not include all package managers with the delivery. Typically a use case is bound to one or two environments at maximum. Thus, it would be overdosed to always supply all package managers. We designed a plugin architecture allowing to add specific package management systems. ts-scan provides the connectivity to the services, but you will have to provide / install them separately. </p>"},{"location":"architecture/#why-does-ts-scan-require-the-eco-systems-being-installed","title":"Why does ts-scan require the eco-systems being installed?","text":"<p>Because we are interested to derive all transitive dependencies as they will end up in the solution you are really delivering. This can only be determined, when you are building the software. To build the software, it is not enough to understand the package list, you will have to look inside the packages. All other  approaches - e.g. file-based scanning only - will not deliver the truth. </p> <p>Please see the Setup for inofrmation on how to install the corresponding ecosystems. </p>"},{"location":"architecture/#is-there-a-preconfigured-image-with-all-eco-systems-setup","title":"Is there a preconfigured image with all eco-systems setup?","text":"<p>We currently do not provide such an image. It would be quiet large and we do not want to maintain it. However, we do provide a Docker image for operating ts-scan, but without any added environments. This would be a good starting point, if you plan to  there are environment specific images available at DockerHub. Alternatively you might want to use the preconfigured image from OSS Review Toolkit (ORT), which does scanning the same way. ORT has a TrustSource format reporter included and thus, these findings can be uploaded to TrustSource as well. </p>"},{"location":"architecture/#further-development","title":"Further development","text":"<p>It is possible - and highly desired - to extend ts-scan with additional package management systems. In the developer's guide we describe how simple it is, to extend it using the plugin mechanism of Python.</p> <p>To add extensions on the file assessment, we recommend to extend ts-deepscan, which is living in a separate repository.</p> <p>To learn more about our plans, see the roadmap.</p>"},{"location":"container/","title":"Operate ts-scan in a docker container","text":"<p>ts-scan can be operated in a container. This might be useful, if you want to operate it in a CI/CD chain or as part of a software factory setup and prevent issues with installation, different python versions, etc..</p>"},{"location":"container/#pull-the-docker-image","title":"Pull the docker image","text":"<p>We do maintain a docker image that includes all supported package management systems. This has the advantage, that you must not setup the package managers to asses particular packagemanagement systems. Whenever ts-scan finds the indication of a supported system, it will use it to determine the trasnsitive dependencies. Whenever we provide a new version of ts-scan, the docker image is automatically build and uploaded to dockerhub, using the ts-scan version as tag. Pulling the <code>latest</code> tag will always pull the updated version. You may make use of it in your code pipelines.</p> <pre><code>docker pull ts-scan:latest\n</code></pre>"},{"location":"container/#build-the-docker-image","title":"Build the docker image","text":"<p>To simplify usage within docker, we provided a dockerfile in the root of the repository. It will build on the official <code>python3.12-slim</code> image.  </p> <p>[!NOTE]</p> <p>Some libraries used by ts-deepscan, the file assessment tool, are implemented more natively. This leads to environment specific builds of the dockerfile. Please make sure to remember, when preparing for distributed use.</p>"},{"location":"container/#build-a-docker-image-containing-ts-scan-x86-64","title":"Build a docker image containing ts-scan (x86-64)","text":"<p>Clone the repo and </p> <pre><code>cd &lt;path to the ts-scan&gt;\ndocker build -t ts-scan .\n</code></pre>"},{"location":"container/#build-a-docker-image-containing-ts-scan-arm","title":"Build a docker image containing ts-scan (ARM)","text":"<p>Due to some restrictions ARM processors will require som, modified build. </p> <pre><code>cd &lt;path to the ts-scan&gt;\ndocker buildx build --platform linux/amd64 -t ts-scan .\n</code></pre> <p>Reason for this difference is, that <code>pyminr</code> - the crypto scanner - might fail to install on ARM chips. </p> <p>Also Scancode is using some libs in the default installation, which are not available to the ARM platform. There we provide only the mini-variant. However, this is covered by ts-scan setup routine and does not require your attention. </p>"},{"location":"container/#use-ts-scan-from-the-docker-image","title":"Use ts-scan from the docker image","text":"<pre><code>docker run ts-scan &lt;COMMAND&gt;\n</code></pre> <p>Replace <code>&lt;COMMAND&gt;</code> with whatever action you want to perform. See our use cases for more details. </p> <p>[!CAUTION] </p> <p>Scanning of Docker images using Syft from within the ts-scan Docker image is not supported for security reasons! It would require excessive privileges, so that we recommend to scan docker images from local.</p>"},{"location":"convert/","title":"Convert","text":"<p>ts-scan allows to export its findings into typical standards such as CycloneDX, SPDX or the TrustSource format. This capability can be used to convert CyDX into SPDX or vice versa. </p> <p>Unfortunately, not all of the formats have the same power in all details. This mainly is a result from their history. SPDX for example, coming primarily from the license compliance, has much more powerful featurs when it comes to license clearing than CyDX. Thus, a conversion form SPDX to CyDX will not be loss free. </p> <p>On the other hand, CyDX is much more capable to transport vulnerability or file specific information. Here the conversion into SPDX most likely will not be possible without information loss. However, we ensure, that a valid file stands at the end of the convesion. </p> <p>Currently the following specificatios are supported:</p> <ul> <li>Cyclone DX v1.6, v1.4</li> <li>SPDX v2.3, v2.2</li> <li>TrustSource v1.0</li> </ul> <p>By default, exports will always provide the latest specification version. Currently you may not use CONVERT to write to an older version of the specification. However, you may import an older version and convert it into a valid newer version.</p> <p>[!NOTE]</p> <p>The conversion always will pass through the TrustSource format, which is our internal representation. Since TrustSource is not a standard, we can be more flexible. But it may be, that there are requirements we did not yet cover. So please, feel free to raise issues, if you require additional features or are missing / loosing data.</p>"},{"location":"convert/#cydx-2-spdx","title":"CyDX 2 SPDX","text":"<p>To convert a CycloneDX file with the name \"MyCydx-file.json\" in cyclonedx-json format into the SPDX file \"MySPDX\" in XML structure, use :</p> <pre><code>ts-scan convert -o MyNewSPDX.xml -of spdx-xml -f cyclonedx-json MyCydx-file.json\n</code></pre> <p>You may switch the output formats accordingly. ts-scan supports <code>[ts|spdx-tag|spdx-json|spdx-yaml|spdx-xml|cyclonedx-json|cyclonedx-xml]</code></p> <p>[!CAUTION]</p> <p>When transforming CycloneDX into SPDX, CBOM and data from other extensions will always be skipped! SPDX does not have an approoriate means to store this information in v2.3.  </p>"},{"location":"convert/#spdx-2-cyclonedx","title":"SPDX 2 CycloneDX","text":"<p>To convert a SPDX file with the name \"MySpdx-file.json\" in spdx-json format into the CycloneDX file \"MyNewCydx\" in XML structure, use :</p> <pre><code>ts-scan convert -o MyNewCydx.xml --output-format cyclonedx-xml -f spdx-json MySpdx-file.json \n</code></pre> <p>[!CAUTION]</p> <p>When transforming SPDX into CycloneDX you must note that the structure will change drastically. The way relations are managed differs. This may lead to data loss.   </p>"},{"location":"convert/#spdx-2-trustsource","title":"SPDX 2 TrustSource","text":"<p>To convert a SPDX file with the name \"MySpdx-file.json\" in spdx-json format into the TrustSource file \"MyNewTS-file\" in JSON format, use :</p> <pre><code>ts-scan convert -o MyNewTS-file.json -of ts -f spdx-json MySpdx-file.json\n</code></pre>"},{"location":"convert/#cyclonedx-2-trustsource","title":"CycloneDX 2 TrustSource","text":"<p>To convert a CycloneDX file with the name \"MyCydx-file.json\" in cyclonedx-json format  into the TrustSource file \"MyNewTS-file\" in JSON format, use :</p> <pre><code>ts-scan convert -o MyNewTS-file.ts --output-format ts -f cyclonedx-json MyCydx-file.json \n</code></pre>"},{"location":"convert/#trustsource-2-cyclonedx","title":"TrustSource 2 CycloneDX","text":"<p>By default ts-scan will always export into CycloneDX v1.6.. To convert a TrustSource file with the name \"MySpdx-file.json\" in spdx-json format into the CycloneDX file \"MyNewCydx\" in XML structure, use :</p> <pre><code>ts-scan convert -o MyNewCydx.xml -of cyclonedx-xml -f ts MyTrustSource-file.ts \n</code></pre> <p>[!CAUTION]</p> <p>DeepScan details will not be available in CycloneDX format. ts-scan will try to bundle information from all files related to a component into the component meatdata. But this does not leave room for the positions of the findings within a file or other sort of details avaialble to TrustSource files. </p>"},{"location":"convert/#trustsource-2-spdx","title":"TrustSource 2 SPDX","text":"<p>By default, ts-scan will export into SPDX v2.3. To convert a SPDX file with the name \"MySpdx-file.json\" in spdx-json format into  into the SPDX file \"MySPDX\" in XML structure, use:</p> <pre><code>ts-scan convert -o MySPDX.xml --output-format spdx-xml -f cyclonedx-json MyCydx-file.json\n</code></pre> <p>[!CAUTION]</p> <p>Deepscan details will not be available in SPDX files.  Especially DeepScan data, such as position of findings within files, quality of license matches, ect., can't be represented in SPDX.</p>"},{"location":"encryption/","title":"Scanning for crypto algorithms","text":"<p>ts-scan also supports to scan for crypto algorithms. Using the deepscan extension pyminr, which ia a wrapper around the minr implementation by SCANOSS, DeepScan is able to assess files for known encryption implementations.</p> <p>Encryption analysis is enabled by default. There are two options for the crypto analysis:</p> <ul> <li> <p>Analysis of a directory content. Can be useful when only the source code from a directory has to be scanned</p> </li> <li> <p>Analysis of the dependencies files. In this case files of every dependency from a dependecy scan will be analysed as long as they are available. </p> </li> </ul> <p>For example, after scanning a Maven project one can look for used encryption algorithms in the sources of every package as long as they are available in the Maven repository (For most OS packages hosten on Maven Central this will be the case).</p> <p>[!NOTE]</p> <p>Our SCANOSS integration provides two sorts of usage. The first is the default option, using the public knowledge base. The second is to use your private API key and access either a private endpoint or the commercial subscription. SCANOSS does not provide different datasets. The public will be updated in different timelines than the pcomemrcial one. But the major difference are the API limits. The burst rate is much higher in the subscriptions than in the public API. Reach out to learn more, in case you are interested. </p>"},{"location":"encryption/#analysis-of-a-directory-content","title":"Analysis of a directory content","text":"<p>To scan and assess the contents of a directory and collecting the output into a file called <code>scan.json</code>, use the following command:</p> <pre><code>ts-scan analyse -o scan.json &lt;DIRECTORY&gt;\n</code></pre>"},{"location":"encryption/#analysis-of-the-dependencies-files","title":"Analysis of the dependencies files","text":"<p>Itis possible to split the actions into scanning and assessing. Scan a directory for dependencies first and store results into the <code>scan.json</code> file.</p> <pre><code>ts-scan scan -o scan.json &lt;DIRECTORY&gt;\n</code></pre> <p>Next, analyse every depedency from the scan and store the scan together with analysis results into the <code>scan.analysed.json</code> </p> <pre><code>ts-scan analyse -o scan.analysed.json scan.json\n</code></pre> <p>The analysis of the encryption algorithms uses the SCANOSS Mining Tool locally. Optionally, you may use the knowledge base provided directly by the SCANOSS. In order to get data about cryptographic algorithms from the SCANOSS services, a SCANOSS API key is required. To make use of the database,  apply the following command:</p> <pre><code>ts-scan analyse --scanoss-api-key &lt;SCANOSS API key&gt; -o scan.analysed.json scan.json\n</code></pre>"},{"location":"encryption/#analysis-results","title":"Analysis results","text":"<p>The analysis results can be found in the output file. The output file contains the original dependency scan as well as a <code>deepscans</code> section containing the \"crypto\" results for each dependency.  The following example shows a snippet from the scan results of a Maven project containing the <code>mvn:org.apache.httpcomponents:httpclient</code> dependency:</p> <pre><code>{\n  ...\n  \"deepscans\": [\n    ...\n      \"mvn:org.apache.httpcomponents:httpclient\": {\n        \"results\": {\n          ...\n          \"httpclient-4.5.14-sources/org/apache/http/impl/auth/DigestScheme.java\": {\n            \"crypto\": [\n              {\n                \"algorithm\": \"MD5\",\n                \"coding\": 128\n              }\n              ...\n            ]\n          },\n          ...\n        }\n    ...\n  ]\n}\n\n</code></pre> <p>If some usage of an encryption algorithm is found in a source file, it appears in the results dictionary of that file under <code>crypto</code> category. In this case a possible usage of an <code>MD5</code> algorithm was found in the <code>org/apache/http/impl/auth/DigestScheme.java</code> in the <code>org.apache.httpcomponents:httpclient</code> package.  </p> <p>[!NOTE]</p> <p>If several analysers found results all results will appear in that dictionary but every analyser will have a separate category.</p>"},{"location":"export/","title":"Export findings","text":"<p>ts-scan allows to export its findings into local files as simple JSON or following standards such as CycloneDX, SPDX or TrustSource format.  One of the latter will be required to upload to the TrustSource platform.</p> <p>To scan dependencies and store the results in <code>spdx-json</code> format in the file named <code>scan.json</code>,  use:  </p> <pre><code>ts-scan scan -f spdx-json -o scan.json &lt;PATH&gt;\n</code></pre> <p>Supported output formats:</p> <ul> <li>SPDX: <code>spdx-json</code>, <code>spdx-xml</code>, <code>spdx-yaml</code>, <code>spdx-xml</code></li> <li>CycloneDX: <code>cyclonedx-json</code>, <code>cyclonedx-xml</code></li> <li>TrustSource: ts-json, default</li> </ul> <p>You may use ts-scan to convert between different formats, see the CONVERT section for more details.</p>"},{"location":"format/","title":"About ts format","text":"<p>ts-scan delivers all scans using the TrustSource format as default. You may export the findings in a standard like CycloneDX or SPDX. But to leverage all potential of TrustSource, we recommend to use the TrustSource format. Since it is not a standard, we are more felxible to our needs. We do not need to run through a consortium to get our demands accepted, we just change it accrodngly. However, we keep compatibility to the standards. Exports will always be supported. Yes, data loss may occur.  </p>"},{"location":"format/#basic-structure","title":"Basic structure","text":"<p>In its current version 1.1 the format uses a tree structure to represent dependencies. All other formats are graph oriented representations. This is difficult to read for peopple, but simple to work with for machines. TrustSource decided to allow both. In the upcoming v1.2 we will keep to show the dependency structure as a tree, but allow to add grpah strutcured dependencies ain addition. This will help to better represent cyclic dependencies. </p> <p>As shown in the following snippet, the format consists mainly of four keys:</p> <pre><code>[\n  {\n    \"module\": \"\",\n    \"moduleId\": \"\", \n    \"dependencies\": [],\n    \"deepscans\": {}\n  }\n]\n</code></pre> <p>While the first two are used for identification of the following entries, e.g. in the TrustSource Platform all scans belong either to a project or a module, the dependencies key holds the root node of the transitive dependencies section. The last key, is the deepscan root node.  In this section the deepscan of any element containing files will be found.</p>"},{"location":"format/#dependencies-section","title":"Dependencies Section","text":"<p>Here is an example containing information for a package called ts-java-client. This has been the former communication client used to transfer scans to TrustSource.</p> <pre><code>[\n  {\n    \"module\": \"ts-java-client\",\n    \"moduleId\": \"mvn:de.eacg:ts-java-client:0.4.6\", \n    \"dependencies\": [\n        {\n            \"key\": \"mvn:de.eacg:ts-java-client\",\n            \"name\": \"ts-java-client\",\n            \"type\": \"maven\",\n            \"namespace\": \"de.eacg\",\n            \"repoUrl\": \"https://github.com/trustsource/ts-java-client\",\n            \"homepageUrl\": \"\",\n            \"description\": \"\",\n            \"checksum\": \"\",\n            \"private\" : false,\n            \"versions\": [\n                \"0.4.6\"\n            ],\n            \"dependencies\" : [],\n            \"licenses\": [\n                {\n                    \"name\" : \"MIT\",\n                    \"url\" : \"https://raw.githubusercontent.com/trustsource/ecs-mvn-plugin/master/LICENSE\",\n            \"kind\" : \"declared\"\n                }\n            ],\n            \"meta\" : {\n                    \"sources\" : {\n                        \"url\": \"https://repo.maven.apache.org/maven2/de/eacg/ecs-java-client/0.4.6/ecs-java-client-0.4.6-sources.jar\"},\n                    \"purl\" : \"pkg:maven \"\n                    },\n                    \"package_files\" : [],\n          \"license_file\": null,\n          \"crypto_algorithms\": []\n            },\n    ],\n   \"deepscans\": {}\n   }\n ]\n</code></pre> <p>In the dependencies section you see the keys associated with each component indentified. most of them are self explanatory. In geenral this is the information declared in the apckage manager systems. ts-scan will populate these fields automatically. And again, you will find the dependencies key with another array. This will carry the transitive dependencies, each with another structure like the one you see for this component.  </p> <p>When you execute the ANALYZE command, ts-scan will walk through the transtive depdencies tree and examine all file-locations, repectively collect the sources and assess them using the ts-deepscan implementation. To learn more about ts-deepscan see here.</p>"},{"location":"format/#deepscan-section","title":"DeepScan Section","text":"<p>The deepscans section will contain information gathered during the analysis phase. Therefor ts-scan uses ts-deepscan to conduct the analysis. ts-deepscan has sepcific analysers to assess files for license information, copyright remarks,crypto algorithms and - latest addon -  also malware via yara.</p> <p>The following structure is a representation of deepscan results you may expect when running a standard analysis. ts-scan will automatically assess all files, it can get hold of for licenses, copyright remarks, create SCANOSS fingerprints and collect information from the SCANOSS database using the public interface.</p> <p>[!Note]</p> <p>Users of SCANOSS may provide their private API key to get a better response rate. See scanning for knonw sources for more details. </p> <pre><code>...\n\"deepscans\": {\n      \"mvn:de.eacg:ecs-java-client\": {\n        \"result\": {\n          \"ecs-java-client-0.4.6-sources/de/eacg/ecs/client/CheckResults.java\": {\n            \"scanoss\": {\n              \"wfp\": \"file=99b9f0eb2aa1f86d2e90e181abde56ca,5462,ecs-java-client-0.4.6-sources/de/eacg/ecs/client/CheckResults.java\\n6=477286a0\\n8=5e7c835d\\n11=c7ac6489,24027ce8\\n13=0076dc47\\n14=d(...) 2\\n225=2676ff36,0fe71b29\\n230=f9a7bd23\\n234=9660b8f3\\n239=9c6be1e7\\n\"\n            },\n            \"links\": [\n              {\n                \"purl\": [\n                  \"pkg:maven/de.eacg/ecs-java-client\",\n                  \"pkg:github/eacg-gmbh/ecs-java-client\"\n                ],\n                \"version\": \"0.4.6\",\n                \"licenses\": [\n                  \"LicenseRef-scancode-proprietary-license\",\n                  \"MIT\"\n                ]\n              }\n            ]\n          },\n         ...\n</code></pre> <p>The first line contains the component. The results section lists the files it containes. Per file the scanoss section contains the fingerprint and links of the purls of the components where this fingerprint is known to appear. The licenses section contains the SPDX license identifiers of the licenses found.</p>"},{"location":"guidelines/","title":"Development Guidelines","text":"<p>We highly appreciate any kind of support to extend the reach and capabilities of ts-scan. However, since it starts becoming a complex tool, we would be happy to see the following guidelines being respected when commiting code. However, we are a small team, so we appreciate every commit. But keeping the guidelines will simplify acceptance of commits and reduce effort for validation.</p> <p>Feel free to reach out and discuss or suggest additional good practise, or maybe just you are in doubt of any statement made here.</p>"},{"location":"guidelines/#standards","title":"Standards","text":"<p>A few years ago we decided to follow the PEP 8 standard. Would be great, if you would comply.</p>"},{"location":"licenses/","title":"Scan for licenses","text":"<p>ts-scan allows to assess packages for declared licenses and files (repository structures) for license indications (effective licenses). This section explains how to use ts-scan for this task and how to use the results, which can be written in CycloneDX, SPDX or TrustSource formats or directly uploaded to TrustSource platform for further processing.</p> <p>License and copyright analysis are enabled by default. There are two options for the license and copyright analysis:</p> <ul> <li> <p>Analysis of a directory content. Can be useful when only the source code from a directory has to be scanned</p> </li> <li> <p>Analysis of the dependencies files. In this case files of every dependency from a dependecy scan will be analysed as long as they are available. </p> </li> </ul> <p>For example, after scanning a Maven project you can try to assess it for license and copyright information in the sources of every package as long as they are available in the Maven repository. For most OS packages hosted on Maven Central this will be the case. However, you may also configure ts-scan to use a private Repository instead (see below).</p>"},{"location":"licenses/#analysis-of-a-directory-content","title":"Analysis of a directory content","text":"<pre><code>ts-scan analyse -o scan.json &lt;DIRECTORY&gt;\n</code></pre>"},{"location":"licenses/#analysis-of-the-dependencies-files","title":"Analysis of the dependencies files","text":"<p>Scan a directory for dependencies first and store results into the <code>scan.json</code> file.</p> <pre><code>ts-scan scan -o scan.json &lt;DIRECTORY&gt;\n</code></pre> <p>Next, analyse every depedency from the scan and store the scan together with analysis results into the <code>scan.analysed.json</code> </p> <pre><code>ts-scan analyse -o scan.analysed.json scan.json\n</code></pre>"},{"location":"licenses/#analysis-results","title":"Analysis results","text":"<p>The analysis results can be found in the output file. The output file contains the original dependency scan as well as a <code>deepscans</code> section containing results for each dependency.  The following example shows a snippet from the scanning results of a Maven projects containing the <code>mvn:com.github.java-json-tools:json-patch</code> dependency:</p> <pre><code>{\n  ...\n  \"deepscans\": [\n    ...\n      \"mvn:com.github.java-json-tools:json-patch\": {\n        \"results\": {\n          ...\n          \"json-patch-1.13-sources/com/github/fge/jsonpatch/JsonPatchException.java\": {\n            \"comments\": [\n              {\n                \"licenses\": [\n                  \"LGPL-3.0-only\",\n                  \"Apache-2.0\"\n                ],\n                \"copyright\": [\n                  {\n                    \"clause\": \"Copyright (c) 2014, Francis Galiegue (fgaliegue@gmail.com)\",\n                    \"holders\": [\n                      \"Francis Galiegue\"\n                    ]\n                  }\n                ],\n                \"line\": 1,\n                \"endLine\": 18\n              }\n            ],\n          ...\n        }\n      }\n    ...\n  ]\n}\n\n</code></pre> <p>If some copyright or license information is found in comments in a source file, it appears in the results dictionary of that file under <code>comments</code> category. In this case, references to the licenses LGPL-3.0-only and Apache-2.0 as well as the copyright notice were found in the <code>json-patch-1.13-sources/com/github/fge/jsonpatch/JsonPatchException.java</code> file inside the comment between lines 1 and 18 in the <code>com.github.java-json-tools:json-patch</code> package.  </p> <p>[!NOTE]</p> <p>If several analysers found results all results appear in that dictionary but every analyser has its own category.</p>"},{"location":"malware/","title":"Scanning for malware","text":"<p>ts-scan supports yara to scan for malware. We added it to simplify security checks of 3rd party elements.</p> <p>Yara checks are not enabled by default. The analysis will be file based. You may also pass a directory as target. This can be useful when your organisation has a particular inbound directory for incoming artefacts. However, to better handle the results, it may be useful to scan only one artefact per scan.</p>"},{"location":"malware/#rule-sets","title":"Rule sets","text":"<p>Yara is a great tool but it will only find, what is defined in the rules. To learn more about yara rules, see this site. You may provide / define your own rule set or use a professional 3rd party ruleset, e.g. by virustotal or use some public collections from this awsome list or this community endavour. Unfortunately community endavours seem not to keep up the efforts necessary so that they tend to silence work over time.  </p> <p>Currently we are still experimenting on how to best provide our ruleset and how to update it. However, you should make sure, you are using a suitable rule set for your purpose. Scanning with an outdated ruleset may not help you with most recent threats. </p>"},{"location":"malware/#usage","title":"Usage","text":"<p>To scan a particular file use </p> <pre><code>ts-scan analyse -o &lt;path to the output file&gt; [-f &lt;output format&gt;] --use-yara &lt;path to the project directory&gt;\n</code></pre>"},{"location":"multiscan/","title":"Scanning multi builds","text":"<p>ts-scan has been designed to handle multiple languages at once. This allows to scan mutli-builds, e.g. a Java backend and a Javascript frontend, with the same tool. The <code>scan</code> command will identify the environments used in the work directory and use the appropriate mechanism to identify the transitive dependencies for the SBOM. </p> <p>[!NOTE]</p> <p>Make sure to start the scan in the corresponding path. If the work directory passed to ts-scan does not contain any remains of the build environment, ts-scan will just terminate with a <code>nothing to scan</code> message.</p> <p>ts-scan supports the environments as outlined in the architecture overview. To learn about expansion plans, see the roadmap. You may add languages by yourself. Feel free, we are happy to help!</p> <p>However, ts-scan will always scan everything that it can find and combine the results into one result file. </p>"},{"location":"multiscan/#organising-your-scans","title":"Organising your scans","text":"<p>Depending on your organisation, it may be useful to either have all the findings in one list or in several. Staying with the example from above, assume we have a solution with a Java backend and Javascript based frontend.</p>"},{"location":"multiscan/#combined-results","title":"Combined results","text":"<p>Given you have only a small team of developers working on both, it may be useful to have all information in one place. In this case you would most likely provide the implementations in a single repository. Say you have the correpsonding <code>yarn.lock</code> and <code>pom.xml</code>in the <code>/src</code> folder, you would want to execute:</p> <pre><code>ts-scan scan -o scan-result.json .\n</code></pre> <p>ts-scan will identify the required environments and collect the transitive dependenices. First for maven, then for npm. It will determine the two dependency trees and append them together into one result file.  The result file will contain two SBOMs added into one file. </p>"},{"location":"multiscan/#separate-results","title":"Separate results","text":"<p>Given you have two different teams, you would most likely have the two solutions organised in two separate repositories. This  will prevent ts-scan from finding all in the same place. Thus, you will receive two scan results, most likely you want them to be uploaded into two different modules of your solution.</p> <p>But if you have for some historical reason still both evironments in the same repository with the same root-folder **ts-scan ** would scan both. You may prevent this by skipping one of the languages and executing two scans:</p> <pre><code>ts-scan scan  -o scan-npm-result.json  -f cyclonedx.json --maven:ignore .\n</code></pre> <p>And to receive only the maven result, use:</p> <pre><code>ts-scan scan  -o scan-mvn-result.json  -f cyclonedx.json --npm:ignore .\n</code></pre> <p>The two scans then may be uploaded into different modules, e.g. frontned and backend, within the same project. </p>"},{"location":"roadmap/","title":"ts-scan Roadmap","text":"<p>In our current planning, we prioritise the extension with additional development environments / languages.  In the first place our plan is to add our further existing scanners, so that we can get rid of them and focus on the development of this solution. </p> <p>The next priorities are :</p> <ol> <li>C/C++ via Cmake (Q2/25)</li> <li>Rust via Cargo (Q2/25)</li> <li>Go  (Q3/25)</li> <li>php via Composer (Q4/25)</li> </ol> <p>If you prefer a change in priorities, feel free to reach out. we are flexible to discuss. Or just take it into your hands. We love contributions. See the Contribution Guide for more information.</p> <p>On the other hand we plan to extend the analysis with adding call graph analysis. Primary use case for this sort of analysis result is to better support CVE handling. However, we currently focus on getting the CRA readiness done. In our next platform release CSAF reporting, document handling and automated VEX-generation will be in the focus. This wil charge the damand for call graph analysis...</p> <p>Feel invited to reach out and discuss your priorities. </p>"},{"location":"sbom/","title":"Scan for dependencies (creating SBOMs)","text":"<p>The origin of our scanning efforts has been to create a Software Bill of Materials (SBOM). This is a different job, depending on the ecosystem. There are languages like C or C++, which are mainly organised through <code>include</code>directives in the files themselves, there are package manager driven languages like Python, Java or Java Script. </p> <p>Currently ts-scan has modules supporting a set of package manager driven systems as well as file based structures. The most recent list can bei found in the ts-scan repo or in the Overview.   </p>"},{"location":"sbom/#how-to-scan","title":"How to scan","text":"<p>The scan command searches for package dependencies in your project. By providing a path, ts-scan automatically detects supported package management systems and extracts a full dependency tree. The scan results can be stored in a file using either the internal TS format or one of the supported SBOM formats: SPDX or CycloneDX.</p> <p>To execute a scan and store results into a file, use:</p> <pre><code>ts-scan scan -o &lt;path to the output file&gt; [-f &lt;output format&gt;] &lt;path to the project directory&gt;\n</code></pre> <p>The <code>-f &lt;output format&gt;</code> option controls the output format and can be:</p> <ul> <li><code>ts</code> - the TrustSource internal format (default)</li> <li><code>spdx-[tag|json|yaml|xml]</code> - One of the SPDX formtas, e.g. <code>spdx-json</code></li> <li><code>cyclonedx-[json|xml]</code> - One of the CycloneDX formats, e.g. <code>cyclonedx-json</code></li> </ul> <p>PLEASE NOTE: The <code>&lt;path to the project directory&gt;</code> may also point to the name of a specific solution or project file. Given you have several solutions in one folder, this would allow you to scan only one of them.</p>"},{"location":"sbom/#options","title":"Options","text":"<p>ts-scan contains some general options as well as options that only apply while scanning specific package types. The package specific options are prefixed by the type of the package management system. We use the Package URL Type as a prefix. The following options are valid for most supported package management system:</p> <ul> <li><code>--[maven|npm|nuget|pypi]:ignore</code> - Disable scanning dependencies of the type   </li> <li><code>--[maven|npm|nuget]:executable</code> - Specify a path to the PM executable</li> <li><code>--[maven|npm|nuget]:forward</code> - Forward arguments to the PM's executable</li> </ul> <p>The full list of options including PM specific options can be printed using:</p> <pre><code>ts-scan scan --help\n</code></pre>"},{"location":"sbom/#scanner-executable-path","title":"Scanner executable path","text":"<p>While scanning for  Maven, Node and NuGet, ... dependencies, ts-scan calls corresponding package manager executables. For example, in order to specify a path to the Maven excutable, use the following option:</p> <pre><code>ts-scan scan --maven:executable /opt/local/bin/mvn &lt;PATH&gt;\n</code></pre>"},{"location":"sbom/#forward-custom-parameters-to-a-scanner-executable","title":"Forward custom parameters to a scanner executable","text":"<p>There also is the option to forward parameters to a package manager executable. For example, in order to pass a settings file to Maven, one can use the following combination:</p> <pre><code>ts-scan scan --maven:foward --settings,customSettings.xml &lt;PATH&gt;\n</code></pre>"},{"location":"sbom/#other-options","title":"Other options","text":"<ul> <li><code>--verbose</code> - Enables verbose mode (including output from PM executables, useful for debugging)</li> <li><code>--tag &lt;TAG&gt;</code> - Stores the SCM tag <code>&lt;TAG&gt;</code> in the scan  </li> <li><code>--branch &lt;BRANCH&gt;</code> - Stores the SCM branch <code>&lt;BRANCH&gt;</code> in the scan  </li> </ul>"},{"location":"sbom/#scan-docker-filesimages-with-syft-as-a-backend","title":"Scan Docker files/images with Syft as a backend","text":"<p>ts-scan can use Syft scanner as a backend for dependencies scanning. To enable the Syft scanner, use the following option:</p> <pre><code>ts-scan scan --use-syft &lt;SCANTARGET&gt;\n</code></pre> <p>As a scan target you can specify any type of sources accepted by Syft, for example a local filesystem path or docker images. For more details on supported formats please refer to Syft Supported Sources.</p> <p>Before calling Syft, ts-scan tries to find the Syft executable in default locations, in order to specify a custom location use the following option:</p> <pre><code>ts-scan scan --use-syft --syft-path &lt;syft executable&gt; &lt;SOURCE&gt;\n</code></pre> <p>To pass custom parameters directly to Syft:</p> <pre><code>ts-scan scan --use-syft --Xsyft &lt;option&gt;,&lt;value&gt; &lt;SOURCE&gt;\n</code></pre>"},{"location":"sbom/#scan-docker-images-with-syft","title":"Scan Docker images with Syft","text":"<p>Syft supports many different input types, and one of them is Docker images. To scan a local docker image, use the following command:</p> <pre><code>ts-scan scan --use-syft -o &lt;OUTPUT&gt; docker:&lt;DOCKER IMAGE&gt;\n</code></pre> <p>[!NOTE] </p> <p>Syft will be installed a part of ts-scan. You do not need to install it separately.</p>"},{"location":"security/","title":"Security Policy","text":"<p>Expires: 2028-01-10T20:00:00.000Z</p> <p>At TrustSource we are concerned with the security of your solutions. As our solutions are part of your solution, we also take the security of our solutions very serious. The following segments will help you finding your path across our security support offerings.</p>"},{"location":"security/#security-information","title":"Security Information","text":"<p>For information regarding the security of our solutions, you may </p> <ul> <li>get an understanding of the service status at our System Status Page</li> <li>understand your and our responsibilities by reading the Shared Security Responsibility Model</li> <li>follow our RSS feed on vulnerability disclosure at Vulnerability Disclosure Feed</li> <li>get the Meta data on our CSAF provider (beta)</li> <li>find tool or solution specific security information in the SECURITY.TXT provided in the root of each code repository</li> </ul> <p>PLEASE DO NOT REPORT SECURITY VULNERABILITIES DIRECTLY TO ANY OF THESE CONTACTS OR PAGES. USE THE INSTRUCTIONS BELOW FOR VULNERABILITY REPORTING TO ALLOW US A COORDINATED VULNERABILITY DISCLOSURE.</p> <p>We appreciate and credit all security researchers and friends that support our and our clients security. You will find a list of people that successfully identified, reported a vulnerability in our services in our hall of fabulous security researchers. Occasionally we might run a bug bounty. If you are interested to be invited, feel free to reach out using our Security Contacts Form.</p>"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a vulnerability","text":"<p>Please use the below process to report a vulnerability to us:</p>"},{"location":"security/#report-by-email","title":"Report by Email:","text":"<ul> <li> <p>Email to support @ trustsource.io using the subject Security Alert </p> </li> <li> <p>Emails should contain:</p> <ul> <li>description of the situation and brief issue </li> <li>precise and detailed steps (include screenshots) that will let us reproduce the issue</li> <li>the affected tool(s) and version(s)</li> <li>if of relevance, your environment or</li> <li>any possible mitigations, if known</li> <li>your contact details, so that we may return with questions and know, whom to credit</li> </ul> </li> <li> <p>Please encrypt your message for preventing unwanted 3rd party access to your information by using our public PGP key:</p> </li> </ul> <p>\u200b TRUSTSOURCE PUBLIC KEY FOR VULNERABILITY DISCLOSURE</p> <p>\u200b HOW TO ENCRYPT USING A PRIVATE KEY?</p> <ul> <li> <p>You will receive a reply from one of our engineers within 1 working day acknowledging receipt of the email.</p> </li> <li> <p>You may be contacted by one of our engineers to further discuss the reported item. Please bear with us as we seek to understand the breadth and scope of thereported problem, recreate it, and confirm if there is a vulnerability present.</p> </li> </ul>"},{"location":"security/#alternatively-you-also-may-use-our-web-form","title":"Alternatively, you also may use our web form:","text":"<ol> <li>Please visit https://www.trustsource.io/contact-security</li> <li>You will receive a confirmation email upon submission</li> <li>You may be contacted by one of our engineers to further discuss the reported item within 1 working day. Please bear with us as we seek to understand the breadthand scope of the reported problem, recreate it, and confirm if there is a vulnerability present.</li> </ol>"},{"location":"security/#disclosure","title":"Disclosure:","text":"<p>We will process the information as fast as possible. However, depending on clarity of documentation, impact and mitigation options this may take a while. However, you may assume that we will stick to a 90 days disclosure timeline max.</p>"},{"location":"setup/","title":"Installation","text":"<p>Installation is fairly simple. We do provide a ts-scan as PIP package. To install, you will require a recent (v3.10, v3.11 or v3.12 are tested) Python version installed and pip (v22+). Generally pip  is already contained in your Python distribution but if not, follow pip's installation instruction.</p>"},{"location":"setup/#installation-from-the-pypi-repository","title":"Installation from the PyPI repository","text":"<p>After pip is install you may install from the Pypi repo:</p> <pre><code>pip install ts-scan\n</code></pre>"},{"location":"setup/#installation-from-a-local-folder","title":"Installation from a local folder","text":"<p>Alternatively you may choose to clone the ts-scan repository and install the code directly in your environment: </p> <pre><code>git clone https://github.com/trustsource/ts-scan.git\ncd &lt;path to the ts-scan repo, typically ts-scan&gt;\npip install ./ --process-dependency-links\n</code></pre>"},{"location":"setup/#provide-a-docker-build","title":"Provide a Docker build","text":"<p>For some scenarios you may want to provide ts-scan inside a docker container, e.g. to prevent issues from version conflicts. </p> <p>[!CAUTION]</p> <p>Scanning of Docker images using Syft from within the ts-scan Docker image is not supported for security reasons. </p>"},{"location":"setup/#build-a-docker-image-containing-ts-scan-amd-intel-etc","title":"Build a Docker image containing ts-scan (AMD, intel, etc.)","text":"<pre><code>cd &lt;path to the ts-scan&gt;\ndocker build -t ts-scan .\n</code></pre>"},{"location":"setup/#build-a-docker-image-containing-ts-scan-arm","title":"Build a Docker image containing ts-scan (ARM)","text":"<pre><code>cd &lt;path to the ts-scan&gt;\ndocker buildx build --platform linux/amd64 -t ts-scan .\n</code></pre> <p>Reason for this is, that pyminr - the encryption scanner - might fail to install on ARM chips.</p>"},{"location":"setup/#use-ts-scan-from-the-docker-image","title":"Use ts-scan from the Docker image","text":"<pre><code>docker run ts-scan &lt;COMMAND&gt;\n</code></pre> <p>for further details see the use case from the Overview</p>"},{"location":"setup/#trouble-shooting","title":"Trouble Shooting","text":"<p>This section will contain hints on solving issues during the installation as soon as we get aware of issues. Feel free to report your questions and experiences in the issues section of this repo. </p>"},{"location":"snippets/","title":"Scanning for software snippets","text":"<p>ts-scan also supports scanning for known algorithm snippets. Therefor ts-scan can apply ts-deepscan which implements the capabilitiy to create the winnowing fingerprints SCANOSS is creating in its worknech. This allows ts-scan to request the open source knowledge base from SCANOSS for identifcation of the files. </p> <p>Given you have scanned a maven project, a part of the result may look like this, describing the httpcore component :</p> <pre><code>...\n{\n            \"key\": \"mvn:org.apache.httpcomponents:httpcore\",\n            \"name\": \"httpcore\",\n            \"type\": \"maven\",\n            \"namespace\": \"org.apache.httpcomponents\",\n            \"repoUrl\": \"\",\n            \"homepageUrl\": \"\",\n            \"description\": \"\",\n            \"checksum\": \"95167d269607b358ba3ed7030ccd336dad8591a0\",\n            \"private\": false,\n            \"versions\": [\n              \"4.4.11\"\n            ],\n            \"dependencies\": [],\n            \"licenses\": [],\n            \"meta\": {\n              \"sources\": {\n                \"url\": \"https://repo.maven.apache.org/maven2/org/apache/httpcomponents/httpcore/4.4.11/httpcore-4.4.11-sources.jar\",\n                \"checksum\": {\n                  \"sha1\": \"95167d269607b358ba3ed7030ccd336dad8591a0\"\n                }\n              },\n              \"purl\": \"pkg:maven/org.apache.httpcomponents/httpcore@4.4.11\"\n            },\n            \"package_files\": [\n              \"/Users/YOU/.m2/repository/org/apache/httpcomponents/httpcore/4.4.11/httpcore-4.4.11-sources.jar\"\n            ],\n            \"license_file\": null,\n            \"crypto_algorithms\": []\n          },\n...\ndeepscans : {}\n</code></pre> <p>You may now assess the files of this component for known information. At the end of the file you will find a key deepscans with an empty document. </p> <pre><code>ts-scan analyse -o myclient-analysed-SBOM.ts myclient-SBOM.ts\n</code></pre> <p>After executing the former command you will find the new document being extended in this section with detailed data per file, like in the following example.</p> <pre><code>...\n    \"deepscans\": {\n    ...\n    \"mvn:org.apache.httpcomponents:httpcore\": {\n        \"result\": {\n          \"httpcore-4.4.11-sources/org/apache/http/HttpEntityEnclosingRequest.java\": {\n            \"scanoss\": {\n              \"wfp\": \"file=66b83406362326af33f0a7ee03e21f44,2017,httpcore-4.4.11-sources/org/apache/http/HttpEntityEnclosingRequest.java\\n4=580f6570\\n5=a61a9320\\n6=89ee373b\\n7=b0886638\\n8=bd668b71,fb0d20c4\\n9=028ead5a,cab55853,d7aead00\\n11=93951dcd\\n13=ff5dfccd\\n14=064b3e26\\n15=d3f942b8,8fe9d4f5,2a9536b0\\n16=abbf89cb\\n17=579ca428\\n21=ec9057cf\\n22=4273907d,64cdb0c4\\n24=f76c9f40\\n27=1ac38724,b2402c98\\n30=e3b95bd8\\n34=003e0fd8,3047c233,47acf246\\n38=82fba22d\\n39=25b13733,f0943a74\\n40=16169a0f,c9e631f5,7f4c67b2\\n41=30cbe494,d8c9a300\\n44=8106c1da\\n47=a22e5c36\\n49=447042f1\\n54=f77bcb6f\\n58=2dccdd63\\n\"\n            },\n            \"links\": [\n              {\n                \"purl\": [\n                  \"pkg:github/apache/httpcore\"\n                ],\n                \"version\": \"4.3-beta1-rc1\",\n                \"licenses\": [\n                  \"Apache-2.0\"\n                ]\n              }\n            ]\n          },\n          \"httpcore-4.4.11-sources/org/apache/http/impl/DefaultHttpServerConnection.java\": {\n            \"scanoss\": {\n              \"wfp\": \"file=9c8bfb26668a771b462072d38a60a0f6,2518,httpcore-4.4.11-sources/org/apache/http/impl/DefaultHttpServerConnection.java\\n4=580f6570\\n5=a61a9320\\n6=89ee373b\\n7=b0886638\\n8=bd668b71,fb0d20c4\\n9=028ead5a,cab55853,d7aead00\\n11=93951dcd\\n13=ff5dfccd\\n14=064b3e26\\n15=d3f942b8,8fe9d4f5,2a9536b0\\n16=abbf89cb\\n17=579ca428\\n21=ec9057cf\\n22=4273907d,64cdb0c4\\n24=f76c9f40\\n28=1ac38724,b2402c98\\n30=235b7c46\\n33=246462f0,a4a2fdf2\\n35=351c8a91\\n38=3edd0d02,0abd99fc\\n40=e4bf6bcb,ef5d1f08\\n45=bb5b769e,6bfc96ba\\n52=cee709c8,85fbe786\\n53=1be0cc05\\n56=e290634a,19963438,163b4499,eebb31a2,de6d4c8d,bf7b4b60\\n57=febf1c0e\\n58=d5a9be8f\\n59=3959e5c9,59ab756d\\n60=92f8ce0e\\n61=bb0a06bb\\n63=405a0dd0\\n\"\n            },\n            \"links\": [\n              {\n                \"purl\": [\n                  \"pkg:github/apache/httpcomponents-core\",\n                  \"pkg:maven/io.github.sunny-chung/httpcore5-parent\"\n                ],\n                \"version\": \"4.4.5-rc1\",\n                \"licenses\": [\n                  \"Apache-2.0\"\n                ]\n              }\n            ]\n          },\n  }, \n  ...\n</code></pre> <p>The deepscans section now contains detailed data as well as the fingerprints. Beware, complex components tend to run into several thousands lines of JSON documents when assessing on flie level. </p> <p>However, besides data on all the file data contained within a package, you will also find a summary section at the end of each component details section. This may look like:</p> <pre><code>...\n\"stats\": {\n    \"total\": 263,\n    \"finished\": 263\n}\n\"summary\": {\n    \"licenses\": [],\n    \"coyprights\" : {},\n    \"crypto_algorithms\": {},\n    \"incompatible_licenses\": [],\n    \"links\": {}\n}\n...\n</code></pre> <p>These sections are made for faster processing of findings. The stats section gives control over the processing status. Given, finished is lower than total, some files were not successfully processed.</p> <p>The summary section aggergates all details within the component. Often this contains more licenses than the declared licenses. the copyrights will add all data found within the particular component, So does the list of crypto algorithms. The list of incompatible licenses is the result from an analysis against the OSADL matrix. For example, if an Apache-2.0 and a GPL-2.0 would be identified, they would appear here as an incompatible pair.</p> <p>The links-section contains the component references to packages that contain this fiel as well.   </p> <p>[!NOTE] </p> <p>For this sort of integration we are using the public SCANOSS API, which has a limit of 1000 fingerprints per request. This may lead to longer execution times for larger modules, due to ts-scan breaking down the requests per component into several chunks. </p>"},{"location":"uc01-autoSoCommit/","title":"Use Case #01 - Auto Scan and Publish upon Commit","text":"<p>One of the most relevant cases for ts-scan is to be executed whenever new code is commited to a repository. We suggest to run a scan every time something is commited to the repository. </p>"},{"location":"uc01-autoSoCommit/#why-you-would-want-to-do-this","title":"Why you would want to do this?","text":"<p>The earlier you identify odd code, the less expensive it will be to remove or fix the code. All the integration work, all the testing will not need to happen when your Developers would have knwon the impact before they added the particular library. TrustSource provide a CHECK verb to test particular libraries, components or files from the CLI before adding them. We also recommend to either use the free TrustSource Vulnerability Lake or the platform specific UI to verify known data on components before you aill even add them in to the code.  </p> <p>However, whether this will always be done when time is calling may be written on a different card. But the very first step you may start ensuring that your developers will take the verification requirement serious is, when you require them to pass a successful verification upon checking in their work results. We recommend using pre-commit to ensure such govervnance.</p> <p>This will prevent your developers from commiting dependencies with known vulnerbailities (or weak crypto algorithms, or bad licenses, etc.)</p>"},{"location":"uc01-autoSoCommit/#prerequisites","title":"Prerequisites","text":"<p>The first step is to setup pre-commit, see here for more details. Pre-commit will perform tests before the code is accepted as a commit to the repository. </p> <p>[!NOTE]</p> <p>You also may decide to include this action into a Git-Workflow, e.g. when the build action is part of an automated CI/CD-chain waiting for the next commit. This also would work. The difference to our suggestion is that pre-commit prevents the unwanted extension to even enter the repository.  </p> <p>Please clarify the intended behaviour within your developer community first. See below for further thoughts.</p>"},{"location":"uc01-autoSoCommit/#steps-to-success","title":"Steps to Success","text":"<p>After having installed pre-commit, amend the <code>.pre-commit.yml</code> file as follows:</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: ts-scan\n        name: run ts-scan\n        language: system\n        entry: /bin/sh -c \"ts-scan scan -o scan.json ./ &amp;&amp; \n            ts-scan check \n              --exit-with-failure-on-vulns \n              --base-url https://api.dev.trustsource.io \n              --api-key YOUR_API_KEY\n              -o scan.vulns.json ./scan.json || \n              echo \\\"Evaluation results can be found in the scan.vulns.json\\\" &amp;&amp; \n              exit 1\n        pass_filenames: false\n</code></pre> <p>This will execute ts-scan from the local installation and run a Check-action on the local code. The <code>exit-with-failure-on-vulns</code> option will cause ts-scan to check the findings for vulnearbilities and exit with an exit code of \"1\" in case there are findings. The results can be found in the <code>scan.vulns.json</code>.</p> <p>[!NOTE]  </p> <p>Pleae note the <code>YOUR API KEY</code> variable. This will require a TrustSource API key. See the online help to learn how to create one. We recommend not to store the API key in the config. You may use github secrets or a local vault to keep the key secret.  </p>"},{"location":"uc01-autoSoCommit/#further-considerations","title":"Further Considerations","text":"<p>It is a sort of a philosophical question, whether you want to allow your developers to commit or not. Sometimes it may be more desireable to secure all changes and not prevent commits. In other cases, it may bo of more relevance to keep the code clean and not to allow such obscure commits. Depending on your branching strategy, it might make sense to have different bahviour at different levels. </p> <p>We, for example, prefer to work with feature branches. On these feature branches, we allow all commits to simplify life for  developers and prevention of work loss. But we do not allow merging into main, as long as the ts-scan has findings.  </p>"},{"location":"uc02-SBOM2Git/","title":"Use Case #02 - SBOM 2 Git","text":"<p>Creating SBOMs meanwhile got sort of \"good development practise\". Thus, you should consider to use ts-scan at least to automatically provide an SBOM to your git repository whenever you create a new release. In the following you will learn the steps required to use a github action - could be replaced with any sort of CI/CD runner activity - to generate an SBOM whenever you initiate the creation of a new release and add the resulting SBOM automatically to the repository.</p>"},{"location":"uc02-SBOM2Git/#why-you-would-want-to-do-this","title":"Why you would want to do this?","text":"<ul> <li>Good development practise</li> <li>Will increase the OpenSSF score for your repository</li> <li>You are fine out when it comes to documentation, as everything is already done ;-)</li> <li>Documentation remains alsways up to date</li> </ul>"},{"location":"uc02-SBOM2Git/#prerequisites","title":"Prerequisites","text":"<p>There are many options to achieve the goal. One of them is to add the SBOM creation as part of a pre-commit action. This requires to have pre-commit installed.    </p>"},{"location":"uc02-SBOM2Git/#steps-to-success","title":"Steps to Success","text":"<p>To achieve the automated SBOM geenration upon each commit, follow these steps: </p>"},{"location":"uc02-SBOM2Git/#1-create-sbom-action-script","title":"1. Create SBOM action script","text":"<p>Go to <code>.git/hooks</code>in your repository and add a <code>create-sbom.sh</code> with <code>touch create-sbom.sh</code> and add the following commands:</p> <pre><code># Create a new SBOM file\nts-scan scan -o SBOM-cydx.json -f cyclonedx-json .\n# Add the new file to the commit\ngit add SBOM-cydx.json\n# Exit with a success status\nexit 0\n</code></pre>"},{"location":"uc02-SBOM2Git/#2-make-the-scrip-executable","title":"2. Make the scrip executable","text":"<p>Now allow to execute the script: <code>chmod +x create-sbom.sh</code> and change back to the root folder of your repository.</p>"},{"location":"uc02-SBOM2Git/#3-add-to-pre-commit","title":"3. Add to pre-commit","text":"<p>Create the pre-commit action using <code>touch .pre-commit-config.yaml</code> with the following commands:</p> <pre><code>  - repo: local\n    hooks:\n      - id: create-sbom\n        name: Create SBOM file\n        entry: .git/hooks/create-sbom.sh\n        language: script\n</code></pre> <p>This will execute the script upon any push and ensure the SBOM provided in the repository stays always accurate. </p>"},{"location":"uc02-SBOM2Git/#alternative","title":"Alternative","text":"<p>An alternative would be to create the SBOM in a later step using a github action. Therefor add the folder <code>.github</code> into your repository root and add there the folder <code>workflows</code>. In this folder you put the following YAML file:</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: ts-scan\n        name: run ts-scan\n        language: system\n        entry: /bin/sh -c \"ts-scan scan -o SBOM.cydx -f cyclonedx-json .\"\n\n</code></pre>"},{"location":"uc03-check/","title":"Use Case #03 - Check for Known Vulnerabilities","text":"<p>You may not want to allow your developers to add code containing known vulnerabilities. It is a managment decision whether you want this. In a first emotional reaction this may seem top be a brilliant idea. Thinking a bt deeper, it will not turn out to be such a good option. The same idea preventing the entry of new, vulnerable code will also prevent developers to provide workarounds or protections from known vulnerabilities in underlying components.</p> <p>However, you must not necessarily block the push or pull request, you also might just want your developers to be informaed about the risks. </p>"},{"location":"uc03-check/#why-you-would-want-to-do-this","title":"Why you would want to do this?","text":"<p>The earlier known vulnerabilities are identified, the lower the price to switch to other components.  </p>"},{"location":"uc03-check/#prerequisites","title":"Prerequisites","text":"<p>We suggest to use <code>pre-commit</code> to initiate the scan automatically. <code>pre-commit</code> is a Python based implementation that hooks in the git flow and allows to execute tests before a commit is completed. Only when the tests are successful, the commit is accepted. You may learn more about the tooling here.</p>"},{"location":"uc03-check/#steps-to-success","title":"Steps to Success","text":"<p>Scan a directory for dependencies first and store results into the <code>scan.json</code> file. Then execute the CHECK command to evaluate the SBOM against the project / module specific requirements and receive all known violations. This can be legal issues, vulnerabilities or crypto security. It is open to you, which restrictions you define.</p> <pre><code>repos:\n  - repo: local\n    hooks:\n      - id: ts-scan\n        name: run ts-scan\n        language: system\n        entry: /bin/sh -c \"ts-scan scan -o scan.json ./ &amp;&amp; \n            ts-scan check \n              --exit-with-failure-on-vulns \n              --base-url https://api.dev.trustsource.io \n              --api-key YOUR_API_KEY\n              -o scan.vulns.json ./scan.json || \n              echo \\\"Evaluation results can be found in the scan.vulns.json\\\" &amp;&amp; \n              exit 1\n        pass_filenames: false\n</code></pre> <p>This will execute ts-scan from the local installation and run a Check-action on the local code. The <code>exit-with-failure-on-vulns</code> option will cause ts-scan to check the findings for vulnearbilities and exit with an exit code of \"1\" in case there are findings. The results can be found in the <code>scan.vulns.json</code>.</p> <p>[!NOTE]</p> <p>Pleae note the <code>YOUR API KEY</code> variable. This will require a TrustSource API key. See the online help to learn how to create one. We recommend not to store the API key in the config. You may use github secrets or a local vault to keep the key secret.  </p> <p>The script above equals the following two commands. In the first step an SBOM is created.</p> <pre><code>ts-scan scan -o scan.json &lt;DIRECTORY&gt;\n</code></pre> <p>Then the CHECK command is used to verify tge SBOM and store the findings in the <code>scan.vulns.json</code> file. using TrustSource: </p> <pre><code>ts-scan check -o scan.vulns.json scan.json\n</code></pre>"},{"location":"uc03-check/#further-considerations","title":"Further Considerations","text":"<p>We highly recommend not to add execessive file based analysis to your <code>pre-commit</code> scans. Scanning for encryption, malware or licenses may take more time than a developer might want to wait for a pre-commit check. </p> <p>Please note: Given you are using TrustSource as a standalone version, you may need to modify ts-scan to use another than the public endpoint. </p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#introduction","title":"Introduction","text":"<p>ts-scan is the ultimate scanner resulting from several years of experience with scanning code for license information, vulnerabilities or malware across a plethora of sources, be it plain text files, packages, docker images or even binaries across as many environments as possible.</p> <p>Thus, we strive to provide a sort of a suiss army knife for scanning in the most comprehensive and comfortable way. And since we were not educated to do all day long this sort of work, we designed it to support automation.</p> <p>This help has been designed to support you in making the best use of it. To get a quick entry we outline different use cases and describe how to achieve the particular goal. A general article will give you an overview of the design and another article explains how to use ts-scan together with the TrustSource platform. However, ts-scan is standalone and can be used with every backend.</p> <p>To get a quick intro, jump to any of the following use cases:</p> <ul> <li>Architecture Overview &amp; supported Ecosystems</li> <li>Capabilities<ul> <li>Scanning for dependencies (creating SBOMs)</li> <li>Scanning for licenses</li> <li>Scanning for encryption</li> <li>Scan for Known Vulnerabilities</li> <li>Scan for malware</li> <li>Scan for known software snippets</li> </ul> </li> <li>Operations<ul> <li>Scanning different artefacts</li> <li>Storing and exporting scan results or converting between different formats</li> <li>Automate SBOM generation</li> <li>Prevent vulnerable dependencies to be checked in</li> </ul> </li> </ul>"},{"location":"usage/#overview-of-capabilities","title":"Overview of Capabilities","text":"<p>Typically each tool designer has a specific use case in mind, when starting his work. This also applies to ts-scan. We aimed to provide a tool, that can be used inside any automated CI/CD tool chain with a maximum of flexibility.  This is why we have split the processing into several steps, allowing to handle interim results. </p> <p>For abtter guidance, following will describe the meaning of the verbs:   </p> <ol> <li> <p>SCAN   Use this to determine an SBOM for a particular build artefact. It allows to assess a target - may be a folder, a docker image or a supported build file - for dependencies. The result will be a file written to disk. You may select between different output formats (ts, spdx, CycloneDX). See <code>ts-scan scan --help</code> for details on the CLI or creating SBOMs. </p> </li> <li> <p>ANALYSE     This action allows to assess the identified dependencies in detail. It will take the scan and pull for each identified dependency the sources from either the package management system or your local repository and assess file by file for information. Often this is bound into the first action. Bu we decided to separate this action for performance reasons. While it makes sense to verify the contents of a package when it enters the solution the first time, this activity must not be executed upon every commit. This will help you save time and resources.     ts-scan uses ts-deepscan to assess components. It will be installed automatically during the ts-scan setup. It supports the following types of analysis: </p> <ol> <li>Copyright,</li> <li>License identification,</li> <li>Crypto-algorithms,</li> <li>SCANOSS fingerprints (and SBOM decoration)</li> <li>Yara rules</li> </ol> <p>By default all scans but yara are enabled. You may disable then using flags. See the corresponding scan section for details. </p> </li> <li> <p>CHECK   Allows to evaluate the identified findings against the project specific policies. This has been introduced to allow breaking builds or deployments depending on the findings. You may use CHECK to assess for:</p> </li> <li> <p>Vulnerabilities</p> </li> <li>Licenses &amp; OSADL compatibility matrix</li> <li> <p>Weak encryption   Today ts-scan takes the findings and transfers them to the TrustSource platform. There policies and assessments against these policies are organised and a result is returned. Read our use case #03 to learn how to drive your CI/CD using ts-scan.   To achieve this, a TrustSource API-Key will be required. However, we plan to provide an option, to add a local policy file for local evaulation.</p> </li> <li> <p>IMPORT   The IMPORT allows to transfer any 3rd party SBOM to the TrustSource platform. You may use this, to create new modules in  a project or update an existing module with this data. The IMPORT command will use the IMPORT function of the TrustSource ** API. Thus, the conversion of the file will take place on the platform.</p> </li> <li> <p>UPLOAD   This verb will become relevant, if you want to upload you scan or analysis results to the TrustSource platform. It allows to take any TrustSource result and push it in to the Platform for further management.</p> </li> <li> <p>CONVERT Allows to convert SBOM elements from one format to another. You may see the CONVERT-section for more specifics on the different file formats and the obstacles for sound conversions.</p> </li> </ol> <p>In our daily work this split has turned out to be very useful. We hope it is not too confusing. So feel free to leave us a note how you like it.</p>"},{"location":"usage/#1-executing-a-scan","title":"1. Executing a Scan","text":"<p>You select your scan target and decide upon the desired outcome. Do you want to </p> <p>The scan command searches for package dependencies in your project. By providing a path, ts-scan automatically detects supported package management systems and extracts a full dependency tree. The scan results can be stored in a file using either the internal TS format or one of the supported SBOM formats: SPDX or CycloneDX.</p> <p>To execute a scan and store results into a file, use:</p> <pre><code>ts-scan scan -o &lt;path to the output file&gt; [-f &lt;output format&gt;] &lt;path to the project directory&gt;\n</code></pre> <p>The <code>-f &lt;output format&gt;</code> option controls the output format and can be:</p> <ul> <li><code>ts</code> - the TrustSource internal format (default)</li> <li><code>spdx-[tag|json|yaml|xml]</code> - One of the SPDX formtas, e.g. <code>spdx-json</code></li> <li><code>cyclonedx-[json|xml]</code> - One of the CycloneDX formats, e.g. <code>cyclonedx-json</code></li> </ul>"},{"location":"usage/#options","title":"Options","text":"<p>ts-scan contains some general options as well as options that only apply while scanning specific package types. The package specific options are prefixed by the type of the package management system. We use the Package URL Type as a prefix. The following options are valid for most supported package management system:</p> <ul> <li><code>--[maven|npm|nuget|pypi]:ignore</code> - Disable scanning dependencies of the type</li> <li><code>--[maven|npm|nuget]:executable</code> - Specify a path to the PM executable</li> <li><code>--[maven|npm|nuget]:forward</code> - Forward arguments to the PM's executable</li> </ul> <p>The full list of options including PM specific options can be printed using:</p> <pre><code>ts-scan scan --help\n</code></pre>"},{"location":"usage/#scanner-executable-path","title":"Scanner executable path","text":"<p>While scanning for Maven, Node and NuGet dependencies, ts-scan calls corresponding package manager executables. For example, in order to specify a path to the Maven excutable use the following option</p> <pre><code>ts-scan scan --maven:executable /opt/local/bin/mvn &lt;PATH&gt;\n</code></pre>"},{"location":"usage/#forward-custom-parameters-to-a-scanner-executable","title":"Forward custom parameters to a scanner executable","text":"<p>There are also options to forward parameters to a package manager executable. For example, in order to pass a settings file to Maven, one can use the following combination:</p> <pre><code>ts-scan scan --maven:foward --settings,customSettings.xml &lt;PATH&gt;\n</code></pre>"},{"location":"usage/#configuring-private-repositories-as-source","title":"Configuring private Repositories as source","text":"<p>It is possible to pass arguments or complete configurations to the package manager. This may be useful in case you want it to use a private registry instead the public one, for example. The <code>--[maven|npm|nuget]:forward</code> - option allows to pass arguments to the package manager's executable.</p>"},{"location":"usage/#other-options","title":"Other options","text":"<ul> <li><code>--verbose</code> - Enables verbose mode (including output from PM executables, useful for debugging)</li> <li><code>--tag &lt;TAG&gt;</code> - Stores the SCM tag <code>&lt;TAG&gt;</code> in the scan</li> <li><code>--branch &lt;BRANCH&gt;</code> - Stores the SCM branch <code>&lt;BRANCH&gt;</code> in the scan</li> </ul>"},{"location":"usage/#scan-with-syft-as-a-backend","title":"Scan with Syft as a backend","text":"<p>ts-scan can use Syft scanner as a backend for dependencies scanning. We added this to enable a comprehensive docker image processing. It is not active by default, to enable the Syft scanner, use the following option:</p> <pre><code>ts-scan scan --use-syft &lt;SOURCE&gt;\n</code></pre> <p>As SOURCE you can specify any type of sources accepted by Syft, for example a local filesystem path or a docker image. For more details on supported formats please refer to Syft Supported Sources.</p> <p>Before calling Syft, ts-scan tries to find the Syft executable in default locations, in order to specify a custom location use the following option:</p> <pre><code>ts-scan scan --use-syft --syft-path &lt;syft executable&gt; &lt;SOURCE&gt;\n</code></pre> <p>To pass custom parameters directly to Syft:</p> <pre><code>ts-scan scan --use-syft --Xsyft &lt;option&gt;,&lt;value&gt; &lt;SOURCE&gt;\n</code></pre>"},{"location":"usage/#scan-docker-images-with-syft","title":"Scan Docker images with Syft","text":"<p>Syft supports many different input types, and one of them is Docker images. To scan a local docker image, use the following command:</p> <pre><code>ts-scan scan --use-syft -o &lt;OUTPUT&gt; docker:&lt;DOCKER IMAGE&gt;\n</code></pre>"},{"location":"usage/#2-analysing-a-scan","title":"2. Analysing a Scan","text":"<p>The in-depth dependency analysis is performed using the analyse command, which takes a scan file as input in one of the supported formats: the internal TS format, SPDX, or CycloneDX. Depending on the dependency package, the tool locates its files and scans each one using ts-deepscan. Additionally, it uses SCANOSS to improve and enrich the collected in-depth scanning results. The analyse command can also take a directory as input to directly scan files inside it.</p> <p>To analyse a scan or a directory and store results into a file, use:</p> <pre><code>ts-scan analyse [-f &lt;input format&gt;] [-o &lt;output&gt;] &lt;path to the scan file or directory&gt;\n</code></pre> <p>The <code>-f &lt;input format&gt;</code> option specifies the input format of the scan to be checked (if a scan file is provided as input) and accepts the same values as the <code>&lt;output format&gt;</code> of the scan command.</p> <p>By default, the analyse, command applies ts-deepscan using its default configuration and extends the analysis results with data from SCANOSS API.</p> <p>To disable or fine-tune specific analysis steps, you can use additional options.</p>"},{"location":"usage/#options_1","title":"Options","text":"<ul> <li><code>--disable-deepscan</code> - Disables analysis using DeepScan.</li> <li><code>--disable-scanoss</code> - Disables extending DeepScan results with SCANOSS data.</li> <li><code>--Xdeepscan &lt;OPTION&gt;,&lt;VALUE&gt;</code> - Forwards to the DeepScan scan command.</li> </ul> <p>The <code>--Xdeepscan</code>can be used to configure the DeepScan analysers. For example, to analyse a scan while setting a timeout (in seconds) per file, use:</p> <pre><code>ts-scan analyse --Xdeepscan timeout,30 &lt;path to the scan file or directory&gt;\n</code></pre> <p>For more details on available options for DeepScan, please refer to ts-deepscan documentation. </p> <p>[!NOTE]</p> <p>To allow the processing of even large or very large SBOMs in reasonable time, ts-deepscan is developed to scale. However, the TrustSource platform is cloud hosted and provides a DeepScan-Scaleout that leverages the massive parallel processing capabilities of deepscan. You may define the hardware you want to use and it will automatically ramp up all hardware, initaite and perform the scans, transfer the findings to TrustSource or your own target and ramp down all infrastructure afterwards. This can happen in your own or our data center.  The DeepScan Scaleout has been designed to scan thousands of repositories at a snap.</p>"},{"location":"usage/#3-verify-state-against-policies","title":"3. Verify State against Policies","text":"<p>The ts-scan check command verifies project dependencies for legal issues and known vulnerabilities against project specific policies. It performs these checks using the TrustSource API - where the settings are stored. It supports two modes:</p> <ol> <li>A full check based on the corresponding TrustSource project settings (a TrustSource project is required; refer to TrustSource for more details).</li> <li>A single component check against the TrustSource vulnerability database.</li> </ol> <p>By default, the check command performs a full check. To check only for vulnerabilities, use the <code>--vulns-only</code>option.</p> <p>In addition to vulnerability checks, the full mode also detects potential legal issues, such as license incompatibilities between dependencies or conflicts with the planned distribution model.</p> <p>Both modes support exiting with a non-zero error code (1) if vulnerabilities or legal issues are found, making it highly useful for integration into CI/CD workflows.</p>"},{"location":"usage/#full-scan-check","title":"Full scan check","text":"<p>To execute a full check, use the following command:</p> <pre><code>ts-scan check --project-name &lt;TrustSource project name&gt; --api-key &lt;TrustSource API key&gt; [-f &lt;input format&gt;] [-o &lt;output&gt;] &lt;path to the scan file&gt;\n</code></pre> <p>The options <code>--project-name &lt;TrustSource project name&gt;</code>and <code>--api-key &lt;TrustSource API key&gt;</code>are required for the full scan.</p> <p>[!NOTE]</p> <p>Before executing a full check, you need to create a project in the TrustSource application and upload the scan into the application. To learn more on TrustSource, please refer to TrustSource App</p> <p>The <code>-f &lt;input format&gt;</code> option specifies the input format of the scan to be checked and accepts the same values as the <code>&lt;output format&gt;</code> of the scan command.</p> <p>Optionally, using the <code>-o &lt;output&gt;</code> option, you can store the check results into a JSON file.</p>"},{"location":"usage/#vulnerabilities-only-check","title":"Vulnerabilities-Only check","text":"<p>A vulnerabilities check can be performed by adding a <code>--vulns-only</code> option to the check command:</p> <pre><code>ts-scan check --vulns-only --api-key &lt;TrustSource API key&gt; [-f &lt;input format&gt;] [-o &lt;output&gt;] [--vulns-confidence low|medium|high] &lt;path to the scan file&gt;\n</code></pre> <p>A vulnerabilities-only check does not require creation of the project and uploading the scan before running the check.</p> <p>The <code>--vulns-confidence &lt;level&gt;</code> option allows you to control the confidence level for matching components with affected products listed in security bulletins, such as product/vendor tuples in CVEs. The default value is <code>high</code>, minimizing false positives as much as possible.</p>"},{"location":"usage/#further-options","title":"Further Options","text":"<p>There are several useful options available for both modes, making it easier to integrate the check command into CI/CD pipelines:</p> <ul> <li><code>--exit-on-legal</code> - Exit with a non-zero (1) exit code if legal violations are found (default: <code>on</code>)</li> <li><code>--exit-on-vulns</code> - Exit with a non-zero (1) exit code if vulnerabilities are found (default: <code>on</code>)</li> <li><code>--Werror</code> - Treat vulnerability/legal warnings as errors</li> </ul>"},{"location":"usage/#4-import-3rd-party-sboms-to-trustsource","title":"4. Import 3rd Party SBOMs to TrustSource","text":"<p>Sometimes you may want to import existing scans and assess these further. Whether your suppliers provided you with SBOMs, they stem from a purchased 3rd party product or you just created them with a another scanner does not matter. Every SBOM in SPDX v2.2 or v2.3 or any CycloneDX in v1.4 or v1.6 can be imported to TrustSource for further surveillance and treatment.</p> <p>You may directly send the file to the TrustSource API, see the API-docs for more information or use ts-scan. Supported import formats:</p> <ul> <li>SPDX RDF (spdx-rdf)</li> <li>SPDX JSON (spdx-json)</li> <li>CycloneDX (cyclonedx)</li> </ul> <p>To import a 3rd party SBOM, use</p> <pre><code>ts-scan import -f &lt;SBOM format&gt; -v &lt;SBOM format version&gt; --module &lt;SBOM module name&gt; --module-id &lt;SBOM module id&gt; --project-name &lt;TrustSource project name&gt; --api-key &lt;TrustSource API key&gt; &lt;path to the SBOM file&gt;\n</code></pre>"},{"location":"usage/#5-upload-data-to-trustsource","title":"5. Upload data to TrustSource","text":"<p>Our understanding is that you do not want to produce SBOMs for the sake of SBOMs or because some legal directive requires you to do so. we want the SBOMs to become an integral part of your development efforts and software life-cycle management activities. It builds a relevant piece of information that - when automatically created throughout our software lifecycle - will contain relevant information for the management of the product.</p> <p>With TrustSource, we have made the SBOM the essential piece of truth, which is guiding the Risk Management, the Vulnerability handling and reporting the complete Release Management. Therefor the SBOM should not only be pushed into a repostory. It should be activated and used as the binding element between the management and the development, ensuring a valid picture for every manager. To learn more, see the TrustSource website.</p> <p>The upload command is used to upload scans to the TrustSource App use:</p> <pre><code>ts-scan upload --project-name &lt;TrustSource project name&gt; --api-key &lt;TrustSource API key&gt; &lt;path to the scan JSON file&gt;\n</code></pre> <p>Get more options, e.g. dirceting to a specific enpoint etc. from the help: </p> <pre><code>ts-scan upload --help\n</code></pre>"},{"location":"usage/#getting-support","title":"Getting Support","text":"<p>ts-scan is open source and supported through this repository. As a TrustSource subscriber, you may contact TrustSource support for help. As a community user, please file a ticket with the repo.  </p> <p>You may also find additional information and learning materials on specific scanning issues/topics in our open TrustSource Knowledgebase.</p>"},{"location":"usage/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>TrustSource supports a coordinated vulnerability disclosure procedure for its platform. ts-scan follows that schema and vulnerabilities identified should follow this procedure. Please find all details in our Security Policy.</p>"},{"location":"vulns/","title":"Scanning for vulnerabilities","text":"<p>ts-scan does also assess for known vulnerabilities against the TrustSource vulnerability lake using the <code>check</code> command. </p>"},{"location":"vulns/#usage","title":"Usage","text":"<p>Scan a directory for dependencies first using SCAN and store results into the <code>scan.json</code> file.</p> <pre><code>ts-scan scan -o scan.json &lt;DIRECTORY&gt;\n</code></pre> <p>Next, check the result for known vulnerabilities: </p> <pre><code>ts-scan check --vulns-only -o result.json --api-key &lt;TrustSource API key&gt; scan.json\n</code></pre> <p>[!NOTE]</p> <p>For this action, a TrustSource API key is required, it can be created in the TrustSource application. Free subscriptions are available. See the TrustSource Website for more details.</p> <p>The option <code>--vulns-confidence &lt;level&gt;</code> can be used to control the confidence level (<code>high</code>, <code>medium</code>, <code>low</code>) for matching components with affected products listed in security bulletins, such as product/vendor tuples in CVEs. The default value is <code>high</code>, minimizing false positives as much as possible. Sometimes it can be useful to apply a lower confidence level, e.g. as a  for example use the following command to search with a <code>medium</code>confidence level:  </p> <pre><code>ts-scan check --vulns-only --vulns-confidence medium -o result.json --api-key &lt;TrustSource API key&gt; scan.json\n</code></pre>"}]}